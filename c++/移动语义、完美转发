#2024/3/8
移动语义
  c++11后
  对象赋值时，避免资源的重新分配
  触发移动构造以及移动拷贝构造
    A a;
    A b(std::move(a));
  stl应用

完美转发
  函数模板可以将自己的参数完美地转发给内部调用的其他参数
  完美是指不仅能准确地转发参数的值，还能保证转发的参数的左右值属性不变
  借用万能引用，通过引用的方式接受左右属性的值
    void func(int &n){
      count << "lvalue=" << n << endl;
    }
    void func(int &&n){
      cout << "rvalue=" << n << endl;
    }

    template<typename T>
    void revoke(T &&t){
      func(forward<T>(t)){
    }
  引用折叠规则-----------------------------------------------------保证准确转发参数的值
    参数为左值或左值引用，T&&将转化为int&    revoke(static_cast<int &> n);  int & && t-->int & t
    参数为右值或右值引用，T&&将转化为int&&   revoke(static_cast<int &&> m);  int && && t-->int && t
      revoke(n) int && t-->int & t变为左值引用            只有这种情况右值和右值引用传进来是----↑
  std::forward<T>(v)------------------------------------------保证转发的参数的左右值属性不变
    T为左值引用，v将转化为T类型的左值
    T为右值引用，v将转化为T类型的右值

------------------------------------------------------------------------------------------------------------------------------------------------
产生将亡值的途径
强制类型转换(转为右值引用)
static_cast<X&&>(x1);

临时量实质化
指的是纯右值转换到临时对象的过程。每当纯右值出现在一个需要泛左值的地方时，临时量实质化都会发生，也就是说都会创建一个临时对象并且使用纯右值对其进行初始化，这也符合纯右值的概念，而这里的临时对象就是一个将亡值。
一个例子:
struct X {
    int a;
};
void t3() {
    int b = X().a;
    cout << b << endl;
    cout << X().a << endl; // 事实上这样也可以
}
虽然X()是纯右值, 访问成员变量a需要一个泛左值, 这里会发生临时量实质化, 将X()转为将亡值, 最后才访问a.

C++17之前, 临时变量是纯右值, 只有转为右值引用才是将亡值.
原文链接：https://blog.csdn.net/qq_41437512/article/details/128825852
